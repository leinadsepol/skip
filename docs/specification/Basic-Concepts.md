# Basic Concepts

## Program Structure

A Skip ***program*** consists of one or more [source unit](#sec-Source-Unit)s, each of which has the following form:

**Syntax**

<pre>
  <i>source-unit:</i>
    <i>declaration-list<sub>opt</sub></i>

  <i>declaration-list:</i>
    <i>declaration</i>
    <i>declaration-list</i>   <i>declaration</i>

  <i>declaration:</i>
    <i>global-constant-declaration</i>
    <i>function-declaration</i>
    <i>class-declaration</i>
    <i>trait-declaration</i>
    <i>global-type-constant-declaration</i>
    <i>module-declaration</i>
</pre>

**Defined elsewhere**
* [*class-declaration*](Classes.md#class-declarations)
* [*function-declaration*](Functions.md#function-declarations)
* [*global-constant-declaration*](Constants-and-Variables.md#global-constants)
* [*global-type-constant-declaration*](Types.md#type-constants)
* [*module-declaration*](Modules.md#module-declarations)
* [*trait-declaration*](Classes.md#class-declarations)

**Constraints**

A program must contain one and only one function called [`main`](#program-start-up) declared in the [global module](Modules.md#general).

## Program Start-Up

A program begins execution in its ***entry-point function*** `main`, declared as a public function in the [global module](Modules.md#general). This function has the following form:

```
fun main(): void { … }
```

**Defined elsewhere**
* [`async`](Functions.md#function-declarations)
* [`String`](#sec-RTL-type-String)
* [`^String`](Types.md#reactive-types)

The entry-point function can be called recursively.

## Program Termination

A program terminates normally by reaching the end of the outermost block of the [entry-point function](#program-start-up).

A program may terminate abnormally under various circumstances, such as the detection of an uncaught exception (possibly generated by a failed assertion), or the lack of memory or other critical resource.

## Storage Duration

The lifetime of a variable is the time during program execution that storage for that variable is guaranteed to exist. This lifetime is referred to as the variable's ***storage duration***, of which there are three kinds: automatic, static, and allocated.

A variable having ***automatic storage duration*** comes into being and is initialized at its declaration. An automatic variable's lifetime ends at the end of its [scope](#scope). Automatic variables lend themselves to being stored on a stack where they can help support argument passing and recursion. [Local variables](Constants-and-Variables.md#local-variables) (which includes parameters) have automatic storage duration.

A variable having ***static storage duration*** comes into being and is initialized before its first use; it lives until program termination. That said, Skip does **not** actually have static variables. It does, however, have static constants: [global constants](Constants-and-Variables.md#global-constants) and [class constants](Classes.md#constants). These have static storage duration.

A variable having ***allocated storage duration*** comes into being based on program logic by use of a call to a [constructor](Expressions.md#function-call-operator). Once such storage is no longer needed, it may be reclaimed automatically at runtime via some sort of (unspecified) garbage-collection process. [Class variables](#sec-Class-Variables) have allocated storage duration.

The following examples demonstrate the three storage durations, with the comments indicating the beginning and end of lifetimes for each constant and variable:

```
const myPI: Float = 3.1415926;  // #1
```

Line #1: The static global constant `myPI` is created and bound to a value before the program begins execution.

```
class C(i: Int) {
  const max: Int = 1000;        // #2
  fun toString(): String {
    this.i.toString()
  }
}
```

Line #2: The static class constant `max` is created and bound to a value before the class is used.

```
fun main(): void {
  av1: C = C(100);              // #3a
  doit(true);
  doit(false);
  av2: C = C(200);              // #3b
  …
}                               // #3c
```

Line #3a: A new, unnamed, allocated variable of type `C` is created and initialized. The newly created automatic variable `av1` is then bound to that allocated variable.

Line #3b: A new, unnamed, allocated variable of type `C` is created and initialized. The newly created automatic variable `av2` is then bound to that allocated variable.

Line #3c: Both automatic variables go out of existence, and static and allocated memory may be released.

```
fun doit(p1: Bool) : void {     // #4a
  av1: Int = 10;                // #4b

  if (p1) {
    av2: Float = 1.23;          // #4c
    …
  }                             // #4d
  else {
    av3: String = "hello";      // #4e
    …
  };                            // #4f
}                               // #4g
```

Line #4a: A new automatic variable, `p1`, of type `Bool` is created and bound to a value each time the function is called.

Line #4b: A new automatic variable, `av1`, of type `Int` is created and bound to an `Int` with value `10`.

Line #4c: If `p1 == true`, a new automatic variable, `av2`, of type `Float` is created and bound to a `Float` with value `1.23`.

Line #4d: The automatic variable `av2` goes out of existence.

Line #4e: If `p1 != true`, a new automatic variable, `a3v`, of type `String` is created and bound to a `String` with value `"hello"`.

Line #4f: The automatic variable `av3` goes out of existence.

Line #4g: The automatic variable `av1` and the parameter `p1` go out of existence.

Consider the following recursive function:

```
fun factorial(i: Int): Int {      // #5
  if (i > 1) i * factorial(i - 1)
  else if (i == 0) 1
  else if (i == 1) i
  else 0
}                                 // #6
```

Line #5: A new automatic variable, `i`, of type `Int` is created and bound to a value each time the function is called.

Line #6: The current automatic variable `i` goes out of existence.

## Binding and Assignment

A [variable](Constants-and-Variables.md#constants-and-variables) is associated with a value via ***binding*** or ***assignment***. A binding takes place once in a variable’s life, when that variable is created. (For a local variable, this happens when it is used in a [*bind-mutation-target*](Expressions.md#simple-mutation) context. For a field, this happens when its parent instance is [constructed](Classes.md#constructors).) An assignment takes place when an existing variable is associated a second or subsequent time.

Consider the following example:

```
class Person {id: Int, name: String} { … }
fun f1{x: Float = 0.0}: void {               // #1

  v1: Int = 10;                              // #2
  v2 = "Hello";                              // #3
  !v1 = -5;                                  // #4

  p1 = Person{name => "Smith", id => 102};   // #5
  !p1.name = "Jones";                        // #6

  void
}
```

When function `f1` is called, at Line #1, the parameter `x`---which is a newly created local variable--- is bound to a Float whose value is passed as an argument, or if none is passed, to the default value, `0.0`.

At Line #2, a new, local variable, `v1`, of type `Int` is created and bound to the `Int` value 10.

At Line #3, a new, local variable, `v2`, is created and bound to the value `"Hello"`. `v2`’s type is inferred from the type of the value to which it is bound, in this case, `String`.

At Line #4, the presence of `!` causes the existing, local variable `v1` to be assigned to the `Int` value -5.

At Line #5, the instance of class `Person` is constructed, at which time, its field `id` is bound to the value 102, and its field `name` is bound to the value `"Smith"`. Then the new, local variable `p1` is bound to that instance.

At Line #6, the instance’s field `name` is assigned to the value `"Jones"`.

Binding occurs in the following circumstances:

* When the [simple-mutation operator `=`](Expressions.md#simple-mutation) is used and *simple-mutation-target* does not contain a `!`
* In a function call, each [positional parameter](Functions.md#general) or [named parameter](Functions.md#general) is bound to its corresponding argument
* In a function call, when no corresponding argument is provided, a named parameter is bound to its [*default-value*](Functions.md#function-declarations)
* A constant is bound to the value of its [*initializer*](Expressions.md#general)

Assignment occurs in the following circumstance:

* When the [simple-mutation operator `=`](Expressions.md#simple-mutation) and the [compound-mutation operator `=.`](Expressions.md#compound-mutation) are used and *mutation-target* contains a `!`.

## Scope

An [identifier](Lexical-Structure.md#identifiers) can be used to designate a number of things: constants, variables, functions, class types, class members, type constants, and modules. The same identifier can denote different entities at different points in the program. For each different entity that an identifier designates, the identifier is visible (i.e., can be used) only within a region of program text called its ***scope***. Different entities designated by the same identifier either have different scopes, or are in different [*name spaces*](Lexical-Structure.md#identifiers).

If an identifier designates two different entities in the same name space, the scopes might overlap. If so, the scope of one entity (the inner scope) will be a strict subset of the scope of the other entity (the outer scope). Within the inner scope, the identifier designates the entity declared in the inner scope.

The following distinct scopes exist:

* ***Global scope***: outside of any [module](Modules.md#general), from the point of declaration through to the end of the source unit.
* ***Module scope***: from the point of declaration of a [module](Modules.md#general) through to the end of that module, all module sections included.
* ***Function scope***: from the point of declaration in the [function](Functions.md#function-declarations) through to the end of that function.
* ***Lambda scope***: A lambda has its own scope separate from that of any function inside which that lambda is created.
* ***Block scope***: from the point of declaration in the [block](Expressions.md#blocks) through to the end of that block.
* ***Class scope***: the body of a [class](Classes.md#class-declarations) and any classes derived from it. In the case of the field names in a constructor, their scope extends to the call site at which that constructor is called using [named arguments](Functions.md#general).
* ***Pattern-Branch scope***: From the beginning to the end of the [pattern branch](Expressions.md#pattern-branch-lists).

## Signatures

Each distinct function is characterized by its *signature*.

The ***signature of a global function*** consists of the name of the parent module, the name of the function, the number of type parameters, and the type of each of its parameters. For positional parameters, parameter order is significant, while for named parameters, it isn’t.

The ***signature of a method*** consists of the name of the parent module, the name of the parent class, the name of the method, the number of type parameters. For positional parameters, parameter order is significant, while for named parameters, it isn’t.

The ***signature of a constructor*** consists of the name of the parent module, the name of the parent class, and the type of each of its parameters. For positional parameters, parameter order is significant, while for named parameters, it isn’t.

Two signatures of the same member kind (global function, method, or constructor) are considered to be the same signatures if they have the same parent module, parent class (if appropriate), function/method name, number of type parameters, and number of parameters, with corresponding parameter types. In the case of methods, a parameter type of `inst` is considered to be the same type as any base or ordinary class type.

Signatures are used to determine if one method overrides another. (See [Classes](Classes.md#general).)

Skip does *not* support *overloading*, the process by which multiple, different declarations for the same name are permitted provided each has a different signature.

Modifiers on parameters are not part of a signature.

## Accessibility

A Skip program is made up of contributions from one or more [modules](Modules.md#general). Names declared at the [top level](Basic-Concepts.md#program-structure) of a module can be made publicly accessible to the whole program (the default), or privately accessible to their parent module (via the `private` modifier). In the absence of an accessibility modifier, a top-level name is public.

Classes are declared at the top level of a module. The members of a class each have a default or explicitly declared accessibility. A member with `private` accessibility may be accessed only from within its own class. A member with `protected` accessibility may be accessed only from within its own class and from classes derived from that class (which may reside in a different module). Access to a member with public accessibility is unrestricted. In the absence of an accessibility modifier, a class member is public. That said, the accessibility of the class itself must be taken into account. For example, a public member of a class declared inside a private module, is not accessible outside that module.

## Mutability

Many object types contain one or more data members, called *fields*, which maintain the state of an instance of a particular type of object. For example, a Point type might contain an x- and a y-coordinate. In general, object-oriented languages allow read and write access to such fields (subject to [accessibility](Basic-Concepts.md#accessibility) rules). However, **by default, in Skip, objects are immutable**, as that is intended to be the ordinary operating mode for Skip programs. That said, a field can be modified with the help of appropriate use of `mutable`.

Consider the following class definition:

```
class Foo(mutable value: Int) {             // #1
  mutable fun addOne(): void {              // #2
    this.!value = this.value + 1;           // #3
    void
  }
  fun get(): Int {                          // #4
    this.value
  }
}
```

On line #1, class `Foo` is defined to have one field, called `value`, which is mutable. On line #3, `Foo`’s method `addOne` adds 1 to `value` and stores the result back in `value`. For that, `addOne` needs write access to `value`, which it does not have, by default. So, the `mutable` modifier is applied to method `addOne` in line #2. As method `get` in line #4 does not need write access to `value`, that method need not be declared mutable.

Consider the following global function:

```
fun addOneToMutablefoo(foo: mutable Foo): void {  // #5
  foo.addOne();                             // #6
  void
}
```

It takes one argument, an instance of Foo, and in line #6, that method calls method `Foo.addOne` on that instance. As we saw earlier, `addOne` needs write access to the object, which requires that the parameter `foo` also have the `mutable` modifier, as shown in line #5. (Without that modifier, `addOne` could not be called.)

```
fun main(): void {
  foo: mutable Foo = mutable Foo(1);        // #7
  foo.addOne();                             // #8
  addOneToMutablefoo(foo);                  // #9
  print_raw(if(foo.get() == 3) "OK" else "FAILED")
}
```

Let’s look at the main function. In line #7, a mutable instance of the class `Foo` is constructed, and local variable `foo` is bound to that. In order to preserve the mutability of the new object, `foo` has the `mutable` modifier. Without that, we could not call `addOne` in line #8, or pass `foo` to the global function in line #9.

An object can be made mutable by declaring its type as a [*mutable-type*](Types.md#mutable-types), via the [Mutable Operator](Expressions.md#mutable-operator), or via the [mutable lambda form](Types.md#lambda-types).]

## Native Support

It may be desirable or necessary to write pieces of a Skip program in a language other than Skip. To do so, a way is needed to map such external support to the Skip language, and this is done via the modifier `native`.

Currently, only classes, methods, global functions, and global constants may be marked `native`. In the case of native methods and functions, they have no body; their implementation is provided by the environment. In the case of native global constants, they have no initializer; that is provided by the environment.

Here is an excerpt from the declaration of the predefined native class `Int`, used to represent signed integers; it contains some native methods:

```
native value class Int uses Equality, Orderable, Show {
  native fun ==(Int): Bool;
  native fun +(Int): Int;
  …
}
```

The predefined global function [`debug`](RTL-fun-debug) is a native function:

```
native fun debug<T>(T): void;
```
